\chapter{Introduction}

Petri Nets are a powerful mathematical and graphical notation for modeling, analyzing and designing a wide range of discrete-event systems. Traditionally Petri Nets are divided into low level Petri Nets and high level Petri Nets (HLPNs) also known as Colored Petri Nets (CPNs) \cite{cpn-tools-book}. Colored Petri Nets are much more concise then low level Petri Nets. There are many differences between the two nets. Still the main difference lies in a fact that HLPNs have colored tokens i.e. each color of a token represents different data type where in a case of low level Petri Nets, all (black) tokens correspond to the same data type. A rich feature set of HLPNs helps Petri Net experts to model a wide variety of complex systems, but it comes at a cost - all of it has to be supported by the Petri Net simulator.

In this Master project we design and implement a Simulator for high level Petri Nets. Our Simulator is similar to one which is already available and well known on the market - "CPN tools" \cite{cpntools}. Still the main difference between our tool and already existing tools is that our Simulator conforms to both ISO/IEC standards \cite{15909-1:2004} and \cite{15909-2:2011}. To our knowledge currently there is no such HLPNs simulator supporting both above mentioned standards.

The major part of our project is a design and implementation of an effective algorithm to find legal bindings of transitions which are involved in the transition firing rule. On one hand the transition binding algorithm has to be fast since it has to be capable of dealing with Petri Nets where a number of transitions and places is huge. On the other hand, it has to provide a general infrastructure to plug in new data types and operations easily. Our Simulator has clearly defined extension points where users could plug in their own extensions. A part of the data types and operations which are described in the standard is already supported by the Simulator. Furthermore, another general problem which we address in this work is a transition firing rule. Once enabled transitions are found one needs to know which of them to fire. By experimenting with different Petri Net algorithms it became clear that a transition firing rule is an application dependent. This dependency is reflected in the behavior of the participating parties, the existence or absence of their spontaneous activity. For example, no randomness is involved in "Minimal distance" algorithm \cite{min-dist} i.e. the final result will always be the same no matter in which order the agents send messages to their neighbors. Now let us take "Consensus in Networks" algorithm \cite{reisig}  as our another example. In this algorithm a set of networked sites try to reach a consensus by spontaneously broadcasting their proposal to their neighbors. Each neighbor can accept or reject the offer. It is obvious that acceptance or rejection of a proposal can be easily expressed in a probabilistic manner. Based on these examples we defined an extension point for users to plug in their own implementations of firing rule algorithm. Finally, sometimes the enabled transitions cannot be found due to a number of variables which cannot be resolved. In such cases a user is asked to input a sufficient part of the solution manually to our Simulator in order to continue the simulation.

The second important part of the Simulator is a model for HLPNs runtime behavior. Two main issues were addressed during the design and implementation of a model for HLPNs runtime behavior. The first challenge was to make our model suitable for supporting state space generation in the future. The second, our model has to be efficient with respect to memory usage.

Finally, a user friendly graphical user interface for the Simulator concludes the project. The GUI is built on top of ePNK \cite{epnk} - a model based graphical Petri Net editor providing functionality to create user defined Petri Net extensions. The Simulator can be run in interactive (single step) mode where an expert can control a simulation completely. Sometimes controlling a simulation in a single step mode can be a time consuming task. Thus the Simulator can be run in automatic mode as well. Furthermore, the GUI supports active/inactive transition indication, firing mode can be chosen from a pop up menu by clicking on an active transition, runtime information is depicted next to each place - all these features a supported by our presentation management mechanism which can be easily reused by other applications. 

The Simulator comes with two extensions which can serve as examples for future projects. The first extension deals with a class of network algorithms, in particular "Echo" \cite{echo}, "Consensus in Networks" \cite{reisig} and "Minimal distance" \cite{min-dist} algorithms. To run these algorithms an input graph representing a network is needed. Nodes of the network correspond to participating parties such as agents, sites etc. and edges reflect the the general structure of the network. The second extension was made to help experts where "`playing the token-game` is not enough for understanding the behavior of a complex system". This concept was already presented in \cite{pnvis} where PNVis - a 3D visualization of low level Petri Nets - was introduced. As an improvement of PNVis our extension supports high level Petri Nets. And what is most important, this support comes "out of the box" i.e. one does not need to extend the existing high level Petri Net to make it work with the 3D engine \footnote{For our project we used a 3D visualization engine which was developed in the course \textit{02162 Software Engineering 2} by group F, 2011}. 

All software in this work is implemented in JAVA programming language, using Eclipse platform \cite{website:eclipse} as an underlying infrastructure. Eclipse Modeling Framework (EMF) \cite{website:emf} and Eclipse Graphical Modeling Framework (GMF) \cite{website:gmf} is used in the modeling and GUI part of the project.

A more detailed description of each feature of the Simulator will be given in the following chapters.

